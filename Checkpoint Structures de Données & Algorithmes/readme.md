Structures de Données et Algorithmes de Tri sur VisuAlgo
Après avoir exploré le site VisuAlgo, j'ai interagi avec plusieurs schémas interactifs de structures de données et d'algorithmes de tri. Voici une liste de ceux que je ne connaissais pas encore et les raisons pour lesquelles je ne les maîtrise toujours pas entièrement :

Structures de Données
Fenwick Tree (Binary Indexed Tree)

Pourquoi je ne maîtrise pas : Ce type de structure de données est utilisé pour les problèmes d'agrégation, comme la somme partielle ou les mises à jour de valeurs dans les tableaux. Je n'ai pas encore beaucoup d'expérience pratique avec des problèmes nécessitant des opérations de somme cumulative efficaces, ce qui limite ma compréhension approfondie de son utilité et de son implémentation.
Treap

Pourquoi je ne maîtrise pas : Un Treap combine les propriétés d'un arbre binaire de recherche et d'un tas. La complexité de gérer deux propriétés différentes simultanément (ordre des nœuds et propriétés de tas) rend difficile l'assimilation de cette structure. Je manque d'expérience dans des situations pratiques où un Treap serait la solution optimale.
Splay Tree

Pourquoi je ne maîtrise pas : Les Splay Trees utilisent une technique appelée "splaying" pour équilibrer l'arbre. Le concept de "splaying" à chaque accès pour amener les éléments récemment accédés en haut est encore quelque peu abstrait pour moi. Je n'ai pas encore suffisamment manipulé cette structure pour bien comprendre ses avantages et ses inconvénients en pratique.
B-Tree

Pourquoi je ne maîtrise pas : Les B-Trees sont souvent utilisés dans les systèmes de bases de données et les systèmes de fichiers. Leurs règles complexes de division et de fusion de nœuds, ainsi que la gestion des nœuds internes et feuilles, nécessitent une compréhension approfondie des opérations de disque, domaine dans lequel je manque d'expérience pratique.
Algorithmes de Tri
Bucket Sort

Pourquoi je ne maîtrise pas : Bien que le concept de partitionner les éléments en plusieurs seaux soit simple, l'implémentation pratique et la sélection du nombre et de la taille des seaux restent délicates. Ce tri est moins souvent utilisé dans les applications courantes, ce qui limite mon exposition pratique.
Counting Sort

Pourquoi je ne maîtrise pas : Counting Sort est efficace pour les plages d'éléments limitées, mais nécessite une bonne compréhension de la distribution des éléments. L'optimisation pour des plages plus larges et la gestion efficace de la mémoire sont des aspects que je n'ai pas encore bien explorés.
Radix Sort

Pourquoi je ne maîtrise pas : Ce tri non-comparatif basé sur le tri des chiffres ou des bits nécessite une compréhension approfondie de la manipulation des données à un niveau plus granulaire. La combinaison avec d'autres algorithmes de tri stable pour chaque chiffre augmente la complexité de l'implémentation.
Conclusion
Pour maîtriser ces structures de données et algorithmes, je prévois de :

Étudier des ressources théoriques supplémentaires pour chaque structure et algorithme.
Implémenter ces structures et algorithmes dans divers langages de programmation pour renforcer ma compréhension pratique.
Résoudre des problèmes spécifiques sur des plateformes comme LeetCode, HackerRank ou Codeforces qui nécessitent l'utilisation de ces structures et algorithmes.
